{
  "name": "Extraterrestrial",
  "id": "_FOIQR",
  "sample": {
    "text": "GOOD\nBYE",
    "index": 1,
    "cols": 24,
    "rows": 18,
    "background": "#00f"
  },
  "glyphs": {
    "A": {
      "letter": "A",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  // params.\n  // x = geometry dimensions\n  // y = radial modulo divisions\n  // z = translate\n  // w = rotate\n\n  // pos = (u_rotDynamic * vec4(pos, 1.)).xyz;\n  \n  float dmin = MAX_RAY;\n  \n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.4, -0.5, 0.),\n    vec3(0.0, 0.5, 0.),\n    0.25\n  ); // last arg should be radius\n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.4, -0.5, 0.),\n    vec3(0.0, 0.5, 0.),\n    0.25\n  ); // last arg should be radius\n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n\n\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "B": {
      "letter": "B",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.7",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n\n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap = sdCapsule(\n    pos, \n    vec3(-0.3, 0.45, 0.),\n    vec3(-0.3, -0.45, 0.),\n    0.3\n  ); // last arg should be radius\n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(-0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0.25, -0.05, 0.),\n    0.7*PI,\n    0.3,\n    0.25\n  );\n  \n  float tor2 = sdCappedTorus(\n    vec3((rotate2D(-0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(-0.2, -0.05, 0.),\n    0.7*PI,\n    0.3,\n    0.25\n  );\n\n\n  dmin = min(cap, dmin);\n  dmin = min(tor1, dmin);\n  dmin = min(tor2, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "C": {
      "letter": "C",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  \n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap = sdCapsule(\n    pos, \n    vec3(-0.3, 0.5, 0.),\n    vec3(-0.3, -0.5, 0.),\n    0.3\n  ); // last arg should be radius\n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0., 0., 0.),\n    0.75*PI,\n    0.5,\n    0.25\n  );\n  \n\n\n  \n  dmin = min(tor1, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "D": {
      "letter": "D",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.7",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap = sdCapsule(\n    pos, \n    vec3(-0.4, 0.45, 0.),\n    vec3(-0.4, -0.45, 0.),\n    0.25\n  ); // last arg should be radius\n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(-0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0., 0.1, 0.),\n    0.7*PI,\n    0.5,\n    0.25\n  );\n  \n\n\n  dmin = min(cap, dmin);\n  dmin = min(tor1, dmin);\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "E": {
      "letter": "E",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.7",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.3, 0.45, 0.),\n    vec3(-0.3, -0.45, 0.),\n    0.25\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(-0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.3, -0.5, 0.),\n    vec3(0.3, -0.5, 0.),\n    0.25\n  );\n  \n  float cap4 = sdCapsule(\n    pos, \n    vec3(-0.3, -0., 0.),\n    vec3(0.2, -0., 0.),\n    0.2\n  );\n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(cap3, dmin);\n  dmin = min(cap4, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "F": {
      "letter": "F",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.7",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.3, 0.45, 0.),\n    vec3(-0.3, -0.45, 0.),\n    0.25\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(-0.3, 0.5, 0.),\n    vec3(0.3, 0.5, 0.),\n    0.25\n  );\n  \n  float cap4 = sdCapsule(\n    pos, \n    vec3(-0.3, -0., 0.),\n    vec3(0.25, -0., 0.),\n    0.2\n  );\n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n\n  dmin = min(cap4, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "G": {
      "letter": "G",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap1 = sdCapsule(\n    pos, \n    vec3(0.1, -0.2, 0.),\n    vec3(0.4, -0.2, 0.),\n    0.2\n  ); \n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.4, -0.5, 0.),\n    vec3(0.4, -0.2, 0.),\n    0.2\n  ); \n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0., 0., 0.),\n    0.65*PI,\n    0.5,\n    0.25\n  );\n  \n\n\n  \n  dmin = min(tor1, dmin);\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "H": {
      "letter": "H",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.35, 0.5, 0.),\n    vec3(-0.35, -0.5, 0.),\n    0.3\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.35, 0.5, 0.),\n    vec3(0.35, -0.5, 0.),\n    0.3\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.2, -0., 0.),\n    vec3(0.2, -0., 0.),\n    0.3\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(cap3, dmin);\n  \n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "I": {
      "letter": "I",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.6",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0., 0.5, 0.),\n    vec3(-0., -0.5, 0.),\n    0.25\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(-0.2, -0.55, 0.),\n    vec3(0.2, -0.55, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.2, 0.55, 0.),\n    vec3(0.2, 0.55, 0.),\n    0.25\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(cap3, dmin);\n  \n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "J": {
      "letter": "J",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.65",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap = sdCapsule(\n    pos, \n    vec3(0.25, 0.5, 0.),\n    vec3(0.25, -0.3, 0.),\n    0.25\n  ); // last arg should be radius\n  \n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(1.*PI) * vec3(pos)).xy, pos.z)\n    +vec3(-0.05, -0.25, 0.),\n    0.5*PI,\n    0.3,\n    0.25\n  );\n  \n\n\n  dmin = min(cap, dmin);\n  dmin = min(tor1, dmin);\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "K": {
      "letter": "K",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.35, 0.45, 0.),\n    vec3(-0.35, -0.45, 0.),\n    0.25\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(-0.3, -0.2, 0.),\n    vec3(0.35, 0.45, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.1, 0.2, 0.),\n    vec3(0.35, -0.5, 0.),\n    0.25\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(cap3, dmin);\n  \n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "L": {
      "letter": "L",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.7",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.3, 0.45, 0.),\n    vec3(-0.3, -0.45, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.3, -0.5, 0.),\n    vec3(0.3, -0.5, 0.),\n    0.25\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n\n  dmin = min(cap3, dmin);\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "M": {
      "letter": "M",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.95",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  // params.\n  // x = geometry dimensions\n  // y = radial modulo divisions\n  // z = translate\n  // w = rotate\n\n  // pos = (u_rotDynamic * vec4(pos, 1.)).xyz;\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  float denom1 = PI;\n  float a = atan(pos.x, pos.z);\n\n  float moda1 = mod(a, denom1);\n\n  moda1 = denom1/2.-abs(moda1-denom1/2.);\n  vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  vec3 cappos = modp1;\n  float cap1 = sdCapsule(\n    cappos, \n    vec3(0.35, 0.5, 0.),\n    vec3(0.6, -0.5, 0.),\n    0.25\n  ); \n  float cap2 = sdCapsule(\n    cappos, \n    vec3(0.35, 0.5, 0.),\n    vec3(0., -0.5, 0.),\n    0.25\n  ); \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "N": {
      "letter": "N",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.75",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.4, 0.5, 0.),\n    vec3(-0.4, -0.5, 0.),\n    0.25\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.4, 0.5, 0.),\n    vec3(0.4, -0.5, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.35, 0.5, 0.),\n    vec3(0.35, -0.5, 0.),\n    0.25\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(cap3, dmin);\n  \n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "O": {
      "letter": "O",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap = sdCapsule(\n    pos, \n    vec3(-0.3, 0.5, 0.),\n    vec3(-0.3, -0.5, 0.),\n    0.3\n  ); // last arg should be radius\n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0., 0., 0.),\n    1.*PI,\n    0.5,\n    0.25\n  );\n  \n\n\n  \n  dmin = min(tor1, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "P": {
      "letter": "P",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.7",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap = sdCapsule(\n    pos, \n    vec3(-0.3, 0.45, 0.),\n    vec3(-0.3, -0.45, 0.),\n    0.3\n  ); // last arg should be radius\n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(-0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0.2, -0.05, 0.),\n    0.7*PI,\n    0.3,\n    0.25\n  );\n  \n\n\n  dmin = min(cap, dmin);\n  dmin = min(tor1, dmin);\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "Q": {
      "letter": "Q",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap1 = sdCapsule(\n    pos, \n    vec3(0.1, -0.2, 0.),\n    vec3(0.55, -0.55, 0.),\n    0.2\n  ); \n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0., 0., 0.),\n    1.*PI,\n    0.5,\n    0.25\n  );\n  \n\n\n  \n  dmin = min(tor1, dmin);\n  dmin = min(cap1, dmin);\n  \n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "R": {
      "letter": "R",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.4, 0.5, 0.),\n    vec3(-0.4, -0.45, 0.),\n    0.25\n  ); // last arg should be radius\n  \n  vec3 torpos = pos;\n  torpos.xy = (rotate2D(-0.5*PI) * vec3(pos)).xy;\n  torpos.x += 0.2;\n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(-0.5*PI) * vec3(pos)).xy, pos.z)\n    +vec3(0.25, -0., 0.),\n    0.8*PI,\n    0.3,\n    0.25\n  );\n  \n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.0, 0.1, 0.),\n    vec3(0.3, -0.45, 0.),\n    0.25\n  ); // last arg should be radius\n  \n\n\n  dmin = min(cap1, dmin);\n  dmin = min(tor1, dmin);\n  dmin = min(cap2, dmin);\n  \n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    \n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "S": {
      "letter": "S",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(0.4*PI) * vec3(pos)).xy, pos.z)\n    +vec3(-0.25, -0.07, 0.),\n    0.7*PI,\n    0.3,\n    0.25\n  );\n  \n  float tor2 = sdCappedTorus(\n    vec3((rotate2D(-0.6*PI) * vec3(pos)).xy, pos.z)\n    +vec3(-0.25, -0.07, 0.),\n    0.7*PI,\n    0.3,\n    0.25\n  );\n\n  dmin = min(tor1, dmin);\n  dmin = min(tor2, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "T": {
      "letter": "T",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0., 0.45, 0.),\n    vec3(-0., -0.5, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.4, 0.55, 0.),\n    vec3(0.4, 0.55, 0.),\n    0.25\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n\n  dmin = min(cap3, dmin);\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "U": {
      "letter": "U",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in float c, in float ra, in float rb)\n{\n  vec2 sc = vec2(sin(c),cos(c));\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  // float denom1 = PI;\n  // float a = atan(pos.x, pos.z);\n\n  // float moda1 = mod(a, denom1);\n\n  // moda1 = denom1/2.-abs(moda1-denom1/2.);\n  // vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  // vec3 cappos = modp1;\n  float cap1 = sdCapsule(\n    pos, \n    vec3(0.35, 0.55, 0.),\n    vec3(0.35, -0.15, 0.),\n    0.25\n  ); // last arg should be radius\n  float cap2 = sdCapsule(\n    pos, \n    vec3(-0.35, 0.55, 0.),\n    vec3(-0.35, -0.15, 0.),\n    0.25\n  ); // last arg should be radius\n  \n  \n  float tor1 = sdCappedTorus(\n    vec3((rotate2D(1.*PI) * vec3(pos)).xy, pos.z)\n    +vec3(-0., -0.2, 0.),\n    0.5*PI,\n    0.35,\n    0.25\n  );\n  \n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(tor1, dmin);\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "V": {
      "letter": "V",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  // params.\n  // x = geometry dimensions\n  // y = radial modulo divisions\n  // z = translate\n  // w = rotate\n\n  // pos = (u_rotDynamic * vec4(pos, 1.)).xyz;\n  \n  float dmin = MAX_RAY;\n  \n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.4, 0.5, 0.),\n    vec3(0.0, -0.5, 0.),\n    0.25\n  ); // last arg should be radius\n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.4, 0.5, 0.),\n    vec3(0.0, -0.5, 0.),\n    0.25\n  ); // last arg should be radius\n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "W": {
      "letter": "W",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.95",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n    \n  // params.\n  // x = geometry dimensions\n  // y = radial modulo divisions\n  // z = translate\n  // w = rotate\n\n  // pos = (u_rotDynamic * vec4(pos, 1.)).xyz;\n  \n  float dmin = MAX_RAY;\n  \n  float l = length(vec2(0.)- pos.xz);\n  float denom1 = PI;\n  float a = atan(pos.x, pos.z);\n\n  float moda1 = mod(a, denom1);\n\n  moda1 = denom1/2.-abs(moda1-denom1/2.);\n  vec3 modp1 = vec3(l*sin(moda1), pos.y, l*cos(moda1));\n  \n  \n  vec3 cappos = modp1;\n  float cap1 = sdCapsule(\n    cappos, \n    vec3(0.35, -0.5, 0.),\n    vec3(0.6, 0.5, 0.),\n    0.25\n  ); \n  float cap2 = sdCapsule(\n    cappos, \n    vec3(0.35, -0.5, 0.),\n    vec3(0., 0.5, 0.),\n    0.25\n  ); \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "X": {
      "letter": "X",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  // params.\n  // x = geometry dimensions\n  // y = radial modulo divisions\n  // z = translate\n  // w = rotate\n\n  // pos = (u_rotDynamic * vec4(pos, 1.)).xyz;\n  \n  float dmin = MAX_RAY;\n  \n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.4, 0.5, 0.),\n    vec3(0.4, -0.5, 0.),\n    0.3\n  ); // last arg should be radius\n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.4, 0.5, 0.),\n    vec3(-0.4, -0.5, 0.),\n    0.3\n  ); // last arg should be radius\n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "Y": {
      "letter": "Y",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0., 0.1, 0.),\n    vec3(-0., -0.5, 0.),\n    0.25\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(-0.4, 0.55, 0.),\n    vec3(0., 0.1, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0., 0.1, 0.),\n    vec3(0.4, 0.55, 0.),\n    0.25\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(cap3, dmin);\n\n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": false,
      "error": false,
      "failed": false
    },
    "Z": {
      "letter": "Z",
      "texture": "Nimbus_Sans_Bold",
      "width": "0.8",
      "textureSize": "1",
      "alignToTexture": false,
      "u_0": "MOUSE_X",
      "u_1": "MOUSE_Y",
      "u_2": "0.5",
      "vert": "attribute vec4 a_position;\nattribute vec2 a_texcoord;\nattribute vec2 a_planecoord;\n\nuniform mat4 u_matrix;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nvoid main() {\n  gl_Position =  u_matrix * a_position;\n  v_texcoord = a_texcoord;\n  v_planecoord = a_planecoord;\n}",
      "frag": "#extension GL_OES_standard_derivatives : enable\nprecision highp float;\n\n\n#define PI 3.14159265358979323846\n\n#define ITER 64\n#define MAX_RAY 15.\n#define MIN_MARCH 0.01\n\n#define NUM_GEO 3\n\nuniform sampler2D u_fontTexture;\nuniform vec4 u_crop;\nuniform float u_0;\nuniform float u_1;\nuniform float u_2;\nuniform float u_time;\nuniform vec2 u_position;\nuniform float u_ratio;\n\nvarying vec2 v_texcoord;\nvarying vec2 v_planecoord;\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n////////////////\n// PALETTE    \n////////////////\n\nvec3 pal ( float t, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n  return a + b*cos( 2.*PI*(c*t+d) );\n}\nvec3 pickCol (float x) {\n  // return pal( x, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n  return pal( x, vec3(0.5),vec3(0.5),vec3(2., 1., 0.),vec3(0.5, 0.2, 0.25) );\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nmat3 rotate2D (float rad) {\n  return mat3(cos(rad), -sin(rad), 0.,\n          sin(rad), cos(rad), 0.,\n          0., 0., 1.);\n}\n\nvec3 transform3D (in vec3 pos, in vec4 axis_a, in vec3 trans)\n{\n  axis_a.xyz = normalize(axis_a.xyz);\n  float s = sin(axis_a.w);\n  float c = cos(axis_a.w);\n  float oc = 1.0 - c;\n  \n  mat4 rotMat = mat4(oc * axis_a.x * axis_a.x + c,           oc * axis_a.x * axis_a.y - axis_a.z * s,  oc * axis_a.z * axis_a.x + axis_a.y * s,  0.0,\n                  oc * axis_a.x * axis_a.y + axis_a.z * s,  oc * axis_a.y * axis_a.y + c,           oc * axis_a.y * axis_a.z - axis_a.x * s,  0.0,\n                  oc * axis_a.z * axis_a.x - axis_a.y * s,  oc * axis_a.y * axis_a.z + axis_a.x * s,  oc * axis_a.z * axis_a.z + c,           0.0,\n                  0.,                                 0.,                                 0.,                                 1.0);\n  mat4 transMat = mat4( 1., 0., 0., 0.,\n                        0., 1., 0., 0.,\n                        0., 0., 1., 0.,\n                        -trans.x, -trans.y, -trans.z, 1.);\n  mat4 mat = rotMat * transMat;\n  return (mat * vec4(pos, 1.)).xyz;\n}\n\nfloat map(vec3 pos) {\n  \n  float dmin = MAX_RAY;\n  \n  \n\n  float cap1 = sdCapsule(\n    pos, \n    vec3(-0.4, 0.5, 0.),\n    vec3(0.4, 0.5, 0.),\n    0.25\n  );\n  float cap2 = sdCapsule(\n    pos, \n    vec3(0.4, 0.5, 0.),\n    vec3(-0.4, -0.5, 0.),\n    0.25\n  );\n  float cap3 = sdCapsule(\n    pos, \n    vec3(-0.4, -0.5, 0.),\n    vec3(0.4, -0.5, 0.),\n    0.25\n  );\n  \n\n\n\n  dmin = min(cap1, dmin);\n  dmin = min(cap2, dmin);\n  dmin = min(cap3, dmin);\n  \n  return dmin;\n  // return sdBlobs(modp);\n}\n\n\n\nfloat median(float r, float g, float b) {\n    return max(min(r, g), min(max(r, g), b));\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat charMask() {\n  // MSDF -> SDF\n  vec3 sample = texture2D(u_fontTexture, v_texcoord).rgb;\n  float sigDist = median(sample.r, sample.g, sample.b) - 0.5;\n  sigDist = clamp(sigDist + 0.5, 0., 1.0);\n  // Crop\n  if (u_crop.x > v_texcoord.x\n  ||  u_crop.y < v_texcoord.x\n  ||  u_crop.z > v_texcoord.y \n  ||  u_crop.w < v_texcoord.y) {\n    sigDist = 0.;\n  }\n  \n  return step(0.5, sigDist);\n}\n\nvoid main() {\n  \n  vec2 st = v_planecoord * vec2(2., -2.) + vec2(-1., 1.);\n  st.x = st.x / u_ratio;\n  \n  vec2 dist = u_position-vec2(u_0, u_1);\n  \n  // RAYMARCHING\n  vec3 camPos = vec3(0., 0., 5.);\n  camPos.xz = (rotate2D(dist.x*2.) * vec3(camPos.xz, 1.)).xy;\n  camPos.yz = (rotate2D(dist.y*2.) * vec3(camPos.yz, 1.)).xy;\n  // camPos.xy = vec3(cam) * rotate2D(0.1);\n  \n  vec3 camTar = vec3(0., 0., 0.);\n  \n  vec3 front = normalize(camTar - camPos);\n  vec3 right = normalize(cross(front, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(right, front));\n  \n  float fl = 5.;\n  vec3 rayDir = normalize(vec3(st.x*right + st.y*up + fl*front));\n  \n  vec3 rayPos = camPos;\n  float rayLen = 0.;\n  float FUDGE_FACTOR = 0.3;\n  \n  vec3 glow = vec3(0.3, 0.6, 0.5);\n  float minStep = MAX_RAY;\n  vec3 nor;\n  \n  bool hit = true;\n  \n  float counter = 0.;\n  for (int i=0; i<ITER; i++) {\n    counter ++;\n    \n    float march = map(rayPos);\n    // float fromSurf = abs(march);\n    // rayLen += max(0.001, fromSurf * FUDGE_FACTOR);\n    rayLen += march;\n    rayPos = camPos + rayDir * rayLen;\n\n    // // calc glow\n    minStep = min(minStep, march);\n    \n    if (MAX_RAY < rayLen) {\n      hit = false;\n      break;\n    } \n\n    if (march < MIN_MARCH) {\n      break;\n    }\n    \n  }\n  \n  \n  \n  \n  float form = 0.;\n  vec3 color = vec3(0.);\n  if (hit) {\n    form = 1.;\n    color = pickCol(rayLen/3.+u_time/(1.+u_2*15.)+u_position.x);\n  }\n  \n  \n  \n  \n  \n  gl_FragColor = vec4(color, form);\n}\n\n\n\n\n\n\n\n\n\n",
      "focused": true,
      "error": false,
      "failed": false
    }
  }
}